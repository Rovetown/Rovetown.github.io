
let cacheProbabilityStates = new Map();   // cache for (remainingChests,d1CurrentRelics,d2CurrentRelics,d3CurrentRelics,d4CurrentRelics) -> probability for probabilityOfSuccess=1

// Helper to build a key for the cacheProbabilityStates map
function key(remainingChests, d1CurrentRelics, d2CurrentRelics, d3CurrentRelics, d4CurrentRelics) {
  return `${remainingChests}|${d1CurrentRelics}|${d2CurrentRelics}|${d3CurrentRelics}|${d4CurrentRelics}`;
}

function RUN_STATE(remainingChests, probabilityOfSuccess, d1CurrentRelics, d2CurrentRelics, d3CurrentRelics, d4CurrentRelics, DivineRelicsTotal, wantedD1amount, wantedD2amount, wantedD3amount, wantedD4amount) {
  cacheProbabilityStates.clear();  // clear cache for this run

  // compute probability assuming starting probabilityOfSuccess=1
  const baseProb = stateProb(remainingChests, d1CurrentRelics, d2CurrentRelics, d3CurrentRelics, d4CurrentRelics, DivineRelicsTotal, wantedD1amount, wantedD2amount, wantedD3amount, wantedD4amount);

  // your original GLOBAL_SUM for probabilityOfSuccess=1 would be baseProb
  const result = probabilityOfSuccess * baseProb;

  //console.log("RESULT (GLOBAL_SUM) =", result);
  return result;
}

// This version does NOT take probabilityOfSuccess. It assumes current probabilityOfSuccess = 1
// and handles the splitting internally (1, 1/2, 1/3, 1/4).
function stateProb(remainingChests, d1CurrentRelics, d2CurrentRelics, d3CurrentRelics, d4CurrentRelics, DivineRelicsTotal, wantedD1amount, wantedD2amount, wantedD3amount, wantedD4amount) {
  const numberOfDivineRollSuccesses = key(remainingChests, d1CurrentRelics, d2CurrentRelics, d3CurrentRelics, d4CurrentRelics);
  if (cacheProbabilityStates.has(numberOfDivineRollSuccesses)) return cacheProbabilityStates.get(numberOfDivineRollSuccesses);

  // Base case
  if (remainingChests <= 0) {
    const val = (d1CurrentRelics >= wantedD1amount && d2CurrentRelics >= wantedD2amount && d3CurrentRelics >= wantedD3amount && d4CurrentRelics >= wantedD4amount) ? 1 : 0;
    cacheProbabilityStates.set(numberOfDivineRollSuccesses, val);
    return val;
  }

  const total = d1CurrentRelics + d2CurrentRelics + d3CurrentRelics + d4CurrentRelics;
  let val = 0;

  // --- EARLY PHASES (with implicit probabilities) ---

  if (total <= 2) {
    // 1 branch, probability 1
    val = stateProb(remainingChests - 1, d1CurrentRelics + 1, d2CurrentRelics, d3CurrentRelics, d4CurrentRelics, DivineRelicsTotal, wantedD1amount, wantedD2amount, wantedD3amount, wantedD4amount);
    cacheProbabilityStates.set(numberOfDivineRollSuccesses, val);
    return val;
  }

  if (3 <= total && total <= 5) {
    // 2 branches, each with weight 1/2
    val =
      0.5 * stateProb(remainingChests - 1, d1CurrentRelics + 1, d2CurrentRelics,     d3CurrentRelics,     d4CurrentRelics,     DivineRelicsTotal, wantedD1amount, wantedD2amount, wantedD3amount, wantedD4amount) +
      0.5 * stateProb(remainingChests - 1, d1CurrentRelics,     d2CurrentRelics + 1, d3CurrentRelics,     d4CurrentRelics,     DivineRelicsTotal, wantedD1amount, wantedD2amount, wantedD3amount, wantedD4amount);
    cacheProbabilityStates.set(numberOfDivineRollSuccesses, val);
    return val;
  }

  if (6 <= total && total <= 9) {
    // 3 branches, each with weight 1/3
    val =
      (1/3) * stateProb(remainingChests - 1, d1CurrentRelics + 1, d2CurrentRelics,     d3CurrentRelics,     d4CurrentRelics,     DivineRelicsTotal, wantedD1amount, wantedD2amount, wantedD3amount, wantedD4amount) +
      (1/3) * stateProb(remainingChests - 1, d1CurrentRelics,     d2CurrentRelics + 1, d3CurrentRelics,     d4CurrentRelics,     DivineRelicsTotal, wantedD1amount, wantedD2amount, wantedD3amount, wantedD4amount) +
      (1/3) * stateProb(remainingChests - 1, d1CurrentRelics,     d2CurrentRelics,     d3CurrentRelics + 1, d4CurrentRelics,     DivineRelicsTotal, wantedD1amount, wantedD2amount, wantedD3amount, wantedD4amount);
    cacheProbabilityStates.set(numberOfDivineRollSuccesses, val);
    return val;
  }

  // --- LATE PHASE: CAP LOGIC ON d2CurrentRelics, d3CurrentRelics, d4CurrentRelics ---

  // Case 1: C C C
  if (d2CurrentRelics >= DivineRelicsTotal && d3CurrentRelics >= DivineRelicsTotal && d4CurrentRelics >= DivineRelicsTotal) {
    // only d1CurrentRelics, weight 1
    val = stateProb(remainingChests - 1, d1CurrentRelics + 1, d2CurrentRelics, d3CurrentRelics, d4CurrentRelics, DivineRelicsTotal, wantedD1amount, wantedD2amount, wantedD3amount, wantedD4amount);
    cacheProbabilityStates.set(numberOfDivineRollSuccesses, val);
    return val;
  }

  // Case 2: C C U
  if (d2CurrentRelics >= DivineRelicsTotal && d3CurrentRelics >= DivineRelicsTotal && d4CurrentRelics < DivineRelicsTotal) {
    val =
      0.5 * stateProb(remainingChests - 1, d1CurrentRelics + 1, d2CurrentRelics, d3CurrentRelics,     d4CurrentRelics,     DivineRelicsTotal, wantedD1amount, wantedD2amount, wantedD3amount, wantedD4amount) +
      0.5 * stateProb(remainingChests - 1, d1CurrentRelics,     d2CurrentRelics, d3CurrentRelics,     d4CurrentRelics + 1, DivineRelicsTotal, wantedD1amount, wantedD2amount, wantedD3amount, wantedD4amount);
    cacheProbabilityStates.set(numberOfDivineRollSuccesses, val);
    return val;
  }

  // Case 3: C U C
  if (d2CurrentRelics >= DivineRelicsTotal && d3CurrentRelics < DivineRelicsTotal && d4CurrentRelics >= DivineRelicsTotal) {
    val =
      0.5 * stateProb(remainingChests - 1, d1CurrentRelics + 1, d2CurrentRelics, d3CurrentRelics,     d4CurrentRelics,     DivineRelicsTotal, wantedD1amount, wantedD2amount, wantedD3amount, wantedD4amount) +
      0.5 * stateProb(remainingChests - 1, d1CurrentRelics,     d2CurrentRelics, d3CurrentRelics + 1, d4CurrentRelics,     DivineRelicsTotal, wantedD1amount, wantedD2amount, wantedD3amount, wantedD4amount);
    cacheProbabilityStates.set(numberOfDivineRollSuccesses, val);
    return val;
  }

  // Case 4: U C C
  if (d2CurrentRelics < DivineRelicsTotal && d3CurrentRelics >= DivineRelicsTotal && d4CurrentRelics >= DivineRelicsTotal) {
    val =
      0.5 * stateProb(remainingChests - 1, d1CurrentRelics + 1, d2CurrentRelics,     d3CurrentRelics, d4CurrentRelics,     DivineRelicsTotal, wantedD1amount, wantedD2amount, wantedD3amount, wantedD4amount) +
      0.5 * stateProb(remainingChests - 1, d1CurrentRelics,     d2CurrentRelics + 1, d3CurrentRelics, d4CurrentRelics,     DivineRelicsTotal, wantedD1amount, wantedD2amount, wantedD3amount, wantedD4amount);
    cacheProbabilityStates.set(numberOfDivineRollSuccesses, val);
    return val;
  }

  // Case 5: C U U
  if (d2CurrentRelics >= DivineRelicsTotal && d3CurrentRelics < DivineRelicsTotal && d4CurrentRelics < DivineRelicsTotal) {
    val =
      (1/3) * stateProb(remainingChests - 1, d1CurrentRelics + 1, d2CurrentRelics,     d3CurrentRelics,     d4CurrentRelics,     DivineRelicsTotal, wantedD1amount, wantedD2amount, wantedD3amount, wantedD4amount) +
      (1/3) * stateProb(remainingChests - 1, d1CurrentRelics,     d2CurrentRelics,     d3CurrentRelics + 1, d4CurrentRelics,     DivineRelicsTotal, wantedD1amount, wantedD2amount, wantedD3amount, wantedD4amount) +
      (1/3) * stateProb(remainingChests - 1, d1CurrentRelics,     d2CurrentRelics,     d3CurrentRelics,     d4CurrentRelics + 1, DivineRelicsTotal, wantedD1amount, wantedD2amount, wantedD3amount, wantedD4amount);
    cacheProbabilityStates.set(numberOfDivineRollSuccesses, val);
    return val;
  }

  // Case 6: U C U
  if (d2CurrentRelics < DivineRelicsTotal && d3CurrentRelics >= DivineRelicsTotal && d4CurrentRelics < DivineRelicsTotal) {
    val =
      (1/3) * stateProb(remainingChests - 1, d1CurrentRelics + 1, d2CurrentRelics,     d3CurrentRelics,     d4CurrentRelics,     DivineRelicsTotal, wantedD1amount, wantedD2amount, wantedD3amount, wantedD4amount) +
      (1/3) * stateProb(remainingChests - 1, d1CurrentRelics,     d2CurrentRelics + 1, d3CurrentRelics,     d4CurrentRelics,     DivineRelicsTotal, wantedD1amount, wantedD2amount, wantedD3amount, wantedD4amount) +
      (1/3) * stateProb(remainingChests - 1, d1CurrentRelics,     d2CurrentRelics,     d3CurrentRelics,     d4CurrentRelics + 1, DivineRelicsTotal, wantedD1amount, wantedD2amount, wantedD3amount, wantedD4amount);
    cacheProbabilityStates.set(numberOfDivineRollSuccesses, val);
    return val;
  }

  // Case 7: U U C
  if (d2CurrentRelics < DivineRelicsTotal && d3CurrentRelics < DivineRelicsTotal && d4CurrentRelics >= DivineRelicsTotal) {
    val =
      (1/3) * stateProb(remainingChests - 1, d1CurrentRelics + 1, d2CurrentRelics,     d3CurrentRelics,     d4CurrentRelics,     DivineRelicsTotal, wantedD1amount, wantedD2amount, wantedD3amount, wantedD4amount) +
      (1/3) * stateProb(remainingChests - 1, d1CurrentRelics,     d2CurrentRelics + 1, d3CurrentRelics,     d4CurrentRelics,     DivineRelicsTotal, wantedD1amount, wantedD2amount, wantedD3amount, wantedD4amount) +
      (1/3) * stateProb(remainingChests - 1, d1CurrentRelics,     d2CurrentRelics,     d3CurrentRelics + 1, d4CurrentRelics,     DivineRelicsTotal, wantedD1amount, wantedD2amount, wantedD3amount, wantedD4amount);
    cacheProbabilityStates.set(numberOfDivineRollSuccesses, val);
    return val;
  }

  // Case 8: U U U
  if (d2CurrentRelics < DivineRelicsTotal && d3CurrentRelics < DivineRelicsTotal && d4CurrentRelics < DivineRelicsTotal) {
    val =
      0.25 * stateProb(remainingChests - 1, d1CurrentRelics + 1, d2CurrentRelics,     d3CurrentRelics,     d4CurrentRelics,     DivineRelicsTotal, wantedD1amount, wantedD2amount, wantedD3amount, wantedD4amount) +
      0.25 * stateProb(remainingChests - 1, d1CurrentRelics,     d2CurrentRelics + 1, d3CurrentRelics,     d4CurrentRelics,     DivineRelicsTotal, wantedD1amount, wantedD2amount, wantedD3amount, wantedD4amount) +
      0.25 * stateProb(remainingChests - 1, d1CurrentRelics,     d2CurrentRelics,     d3CurrentRelics + 1, d4CurrentRelics,     DivineRelicsTotal, wantedD1amount, wantedD2amount, wantedD3amount, wantedD4amount) +
      0.25 * stateProb(remainingChests - 1, d1CurrentRelics,     d2CurrentRelics,     d3CurrentRelics,     d4CurrentRelics + 1, DivineRelicsTotal, wantedD1amount, wantedD2amount, wantedD3amount, wantedD4amount);
    cacheProbabilityStates.set(numberOfDivineRollSuccesses, val);
    return val;
  }

  // should never fall through, but just in case:
  cacheProbabilityStates.set(numberOfDivineRollSuccesses, val);
  return val;
}

function comb(numberOfAttempts, numberOfDivineRollSuccesses) {
  if (numberOfDivineRollSuccesses < 0 || numberOfDivineRollSuccesses > numberOfAttempts) return 0;
  if (numberOfDivineRollSuccesses === 0 || numberOfDivineRollSuccesses === numberOfAttempts) return 1;
  let res = 1;
  for (let i = 1; i <= numberOfDivineRollSuccesses; i++) {
    res = res * (numberOfAttempts - (numberOfDivineRollSuccesses - i)) / i;
  }
  return res;
}
function binomPMF(numberOfDivineRollSuccesses, numberOfAttempts, probabilityOfSuccess) {
  return comb(numberOfAttempts, numberOfDivineRollSuccesses) * Math.pow(probabilityOfSuccess, numberOfDivineRollSuccesses) * Math.pow(1 - probabilityOfSuccess, numberOfAttempts - numberOfDivineRollSuccesses);
}


function RELIC_SOLVER (TotalRelicChests, TotalDivineChests, TotalDivineRelics, divineChance, wantedD1amount, wantedD2amount, wantedD3amount, wantedD4amount) {
  let sectionSum = 0
  for (let numberOfDivineRollSuccesses = 0; numberOfDivineRollSuccesses <= TotalRelicChests; numberOfDivineRollSuccesses++) {
    if (Number.isNaN(binomPMF(numberOfDivineRollSuccesses, TotalRelicChests, divineChance))) {
      console.log("numberOfDivineRollSuccesses=", numberOfDivineRollSuccesses, "FINAL RESULT =", sectionSum, "avg gems after numberOfDivineRollSuccesses=", (Math.round(200/sectionSum)).toLocaleString());
      return  sectionSum;
}
    sectionSum+= binomPMF(numberOfDivineRollSuccesses, TotalRelicChests, divineChance) * RUN_STATE(numberOfDivineRollSuccesses + TotalDivineChests, 1.0, 0, 0, 0, 0, TotalDivineRelics, wantedD1amount, wantedD2amount, wantedD3amount, wantedD4amount)
    console.log("numberOfDivineRollSuccesses=", numberOfDivineRollSuccesses, "prob after numberOfDivineRollSuccesses =", sectionSum, "avg gems after numberOfDivineRollSuccesses=", (Math.round(200/sectionSum)).toLocaleString());
  }
  console.log("FINAL RESULT =", sectionSum, "avg gems after numberOfDivineRollSuccesses=", (Math.round(200/sectionSum)).toLocaleString());
  return sectionSum;
}

// TODO: Make this user selectable

let TotalRelicChests =325160
let TotalDivineChests = 6; // amount of divine chests
let TotalDivineRelics = 7; // how many divines you have in total
let divineChance = 1/25000
let wantedD1amount = 8, wantedD2amount = 7, wantedD3amount = 7, wantedD4amount = 7; // amount of divine relics across all 4 divine relic types (or the wanted amount, idk)

RELIC_SOLVER (TotalRelicChests, TotalDivineChests, TotalDivineRelics, divineChance, wantedD1amount, wantedD2amount, wantedD3amount, wantedD4amount);