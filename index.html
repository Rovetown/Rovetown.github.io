<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <title>Relic Solver UI</title>
  <script src="https://unpkg.com/vue@3/dist/vue.global.js"></script>
  <style>
    body {
      font-family: Arial, sans-serif;
      padding: 20px;
      background: #222;
      color: #eee;
    }
    .box {
      margin-bottom: 10px;
    }
    input {
      padding: 5px;
      width: 120px;
    }
    button {
      padding: 10px 20px;
      cursor: pointer;
    }
    pre {
      background: #111;
      padding: 10px;
      margin-top: 20px;
      border-radius: 4px;
    }
  </style>
</head>

<body>
  <div id="app">
    <h1>Relic Solver</h1>

    <div class="box">
      <label>{{ labelTotalRelicChests }}</label>
      <input v-model.number="TotalRelicChests" type="number">
    </div>

    <div class="box">
      <label>{{ labelTotalDivineChests }}</label>
      <input v-model.number="TotalDivineChests" type="number">
    </div>

    <div class="box">
      <label>{{ labelTotalDivineRelics }}</label>
      <input v-model.number="TotalDivineRelics" type="number">
    </div>

    <div class="box">
      <label>{{ labelDivineChance }}</label>
      <input v-model.number="divineChance" type="number" step="0.000001">
    </div>

    <div class="box">
      <label>{{ labelWantedD1 }}</label>
      <input v-model.number="wantedD1amount" type="number">
    </div>

    <div class="box">
      <label>{{ labelWantedD2 }}</label>
      <input v-model.number="wantedD2amount" type="number">
    </div>

    <div class="box">
      <label>{{ labelWantedD3 }}</label>
      <input v-model.number="wantedD3amount" type="number">
    </div>

    <div class="box">
      <label>{{ labelWantedD4 }}</label>
      <input v-model.number="wantedD4amount" type="number">
    </div>

    <div class="box">
      <label>{{ labelCostPerRun }}</label>
      <input v-model.number="costPerRun" type="number">
    </div>

    <div class="box">
      <button @click="runSolver">Run Solver</button>
    </div>

    <pre>{{ output }}</pre>
  </div>

  <script>
    // ---------------------------
    // PUT YOUR ENTIRE SOLVER HERE
    // ---------------------------
    // (paste your exact stateProb, RUN_STATE, RELIC_SOLVER code here)


let cacheProbabilityStates = new Map();   // cache for (remainingChests,d1CurrentRelics,d2CurrentRelics,d3CurrentRelics,d4CurrentRelics) -> probability for probabilityOfSuccess=1

// Helper to build a key for the cacheProbabilityStates map
function key(remainingChests, d1CurrentRelics, d2CurrentRelics, d3CurrentRelics, d4CurrentRelics) {
  return `${remainingChests}|${d1CurrentRelics}|${d2CurrentRelics}|${d3CurrentRelics}|${d4CurrentRelics}`;
}

function RUN_STATE(remainingChests, probabilityOfSuccess, d1CurrentRelics, d2CurrentRelics, d3CurrentRelics, d4CurrentRelics, DivineRelicsTotal, wantedD1amount, wantedD2amount, wantedD3amount, wantedD4amount) {
  cacheProbabilityStates.clear();  // clear cache for this run

  // compute probability assuming starting probabilityOfSuccess=1
  const baseProb = stateProb(remainingChests, d1CurrentRelics, d2CurrentRelics, d3CurrentRelics, d4CurrentRelics, DivineRelicsTotal, wantedD1amount, wantedD2amount, wantedD3amount, wantedD4amount);

  // your original GLOBAL_SUM for probabilityOfSuccess=1 would be baseProb
  const result = probabilityOfSuccess * baseProb;

  //console.log("RESULT (GLOBAL_SUM) =", result);
  return result;
}

// This version does NOT take probabilityOfSuccess. It assumes current probabilityOfSuccess = 1
// and handles the splitting internally (1, 1/2, 1/3, 1/4).
function stateProb(remainingChests, d1CurrentRelics, d2CurrentRelics, d3CurrentRelics, d4CurrentRelics, DivineRelicsTotal, wantedD1amount, wantedD2amount, wantedD3amount, wantedD4amount) {
  const numberOfDivineRollSuccesses = key(remainingChests, d1CurrentRelics, d2CurrentRelics, d3CurrentRelics, d4CurrentRelics);
  if (cacheProbabilityStates.has(numberOfDivineRollSuccesses)) return cacheProbabilityStates.get(numberOfDivineRollSuccesses);

  // Base case
  if (remainingChests <= 0) {
    const val = (d1CurrentRelics >= wantedD1amount && d2CurrentRelics >= wantedD2amount && d3CurrentRelics >= wantedD3amount && d4CurrentRelics >= wantedD4amount) ? 1 : 0;
    cacheProbabilityStates.set(numberOfDivineRollSuccesses, val);
    return val;
  }

  const total = d1CurrentRelics + d2CurrentRelics + d3CurrentRelics + d4CurrentRelics;
  let val = 0;

  // --- EARLY PHASES (with implicit probabilities) ---

  if (total <= 2) {
    // 1 branch, probability 1
    val = stateProb(remainingChests - 1, d1CurrentRelics + 1, d2CurrentRelics, d3CurrentRelics, d4CurrentRelics, DivineRelicsTotal, wantedD1amount, wantedD2amount, wantedD3amount, wantedD4amount);
    cacheProbabilityStates.set(numberOfDivineRollSuccesses, val);
    return val;
  }

  if (3 <= total && total <= 5) {
    // 2 branches, each with weight 1/2
    val =
      0.5 * stateProb(remainingChests - 1, d1CurrentRelics + 1, d2CurrentRelics,     d3CurrentRelics,     d4CurrentRelics,     DivineRelicsTotal, wantedD1amount, wantedD2amount, wantedD3amount, wantedD4amount) +
      0.5 * stateProb(remainingChests - 1, d1CurrentRelics,     d2CurrentRelics + 1, d3CurrentRelics,     d4CurrentRelics,     DivineRelicsTotal, wantedD1amount, wantedD2amount, wantedD3amount, wantedD4amount);
    cacheProbabilityStates.set(numberOfDivineRollSuccesses, val);
    return val;
  }

  if (6 <= total && total <= 9) {
    // 3 branches, each with weight 1/3
    val =
      (1/3) * stateProb(remainingChests - 1, d1CurrentRelics + 1, d2CurrentRelics,     d3CurrentRelics,     d4CurrentRelics,     DivineRelicsTotal, wantedD1amount, wantedD2amount, wantedD3amount, wantedD4amount) +
      (1/3) * stateProb(remainingChests - 1, d1CurrentRelics,     d2CurrentRelics + 1, d3CurrentRelics,     d4CurrentRelics,     DivineRelicsTotal, wantedD1amount, wantedD2amount, wantedD3amount, wantedD4amount) +
      (1/3) * stateProb(remainingChests - 1, d1CurrentRelics,     d2CurrentRelics,     d3CurrentRelics + 1, d4CurrentRelics,     DivineRelicsTotal, wantedD1amount, wantedD2amount, wantedD3amount, wantedD4amount);
    cacheProbabilityStates.set(numberOfDivineRollSuccesses, val);
    return val;
  }

  // --- LATE PHASE: CAP LOGIC ON d2CurrentRelics, d3CurrentRelics, d4CurrentRelics ---

  // Case 1: C C C
  if (d2CurrentRelics >= DivineRelicsTotal && d3CurrentRelics >= DivineRelicsTotal && d4CurrentRelics >= DivineRelicsTotal) {
    // only d1CurrentRelics, weight 1
    val = stateProb(remainingChests - 1, d1CurrentRelics + 1, d2CurrentRelics, d3CurrentRelics, d4CurrentRelics, DivineRelicsTotal, wantedD1amount, wantedD2amount, wantedD3amount, wantedD4amount);
    cacheProbabilityStates.set(numberOfDivineRollSuccesses, val);
    return val;
  }

  // Case 2: C C U
  if (d2CurrentRelics >= DivineRelicsTotal && d3CurrentRelics >= DivineRelicsTotal && d4CurrentRelics < DivineRelicsTotal) {
    val =
      0.5 * stateProb(remainingChests - 1, d1CurrentRelics + 1, d2CurrentRelics, d3CurrentRelics,     d4CurrentRelics,     DivineRelicsTotal, wantedD1amount, wantedD2amount, wantedD3amount, wantedD4amount) +
      0.5 * stateProb(remainingChests - 1, d1CurrentRelics,     d2CurrentRelics, d3CurrentRelics,     d4CurrentRelics + 1, DivineRelicsTotal, wantedD1amount, wantedD2amount, wantedD3amount, wantedD4amount);
    cacheProbabilityStates.set(numberOfDivineRollSuccesses, val);
    return val;
  }

  // Case 3: C U C
  if (d2CurrentRelics >= DivineRelicsTotal && d3CurrentRelics < DivineRelicsTotal && d4CurrentRelics >= DivineRelicsTotal) {
    val =
      0.5 * stateProb(remainingChests - 1, d1CurrentRelics + 1, d2CurrentRelics, d3CurrentRelics,     d4CurrentRelics,     DivineRelicsTotal, wantedD1amount, wantedD2amount, wantedD3amount, wantedD4amount) +
      0.5 * stateProb(remainingChests - 1, d1CurrentRelics,     d2CurrentRelics, d3CurrentRelics + 1, d4CurrentRelics,     DivineRelicsTotal, wantedD1amount, wantedD2amount, wantedD3amount, wantedD4amount);
    cacheProbabilityStates.set(numberOfDivineRollSuccesses, val);
    return val;
  }

  // Case 4: U C C
  if (d2CurrentRelics < DivineRelicsTotal && d3CurrentRelics >= DivineRelicsTotal && d4CurrentRelics >= DivineRelicsTotal) {
    val =
      0.5 * stateProb(remainingChests - 1, d1CurrentRelics + 1, d2CurrentRelics,     d3CurrentRelics, d4CurrentRelics,     DivineRelicsTotal, wantedD1amount, wantedD2amount, wantedD3amount, wantedD4amount) +
      0.5 * stateProb(remainingChests - 1, d1CurrentRelics,     d2CurrentRelics + 1, d3CurrentRelics, d4CurrentRelics,     DivineRelicsTotal, wantedD1amount, wantedD2amount, wantedD3amount, wantedD4amount);
    cacheProbabilityStates.set(numberOfDivineRollSuccesses, val);
    return val;
  }

  // Case 5: C U U
  if (d2CurrentRelics >= DivineRelicsTotal && d3CurrentRelics < DivineRelicsTotal && d4CurrentRelics < DivineRelicsTotal) {
    val =
      (1/3) * stateProb(remainingChests - 1, d1CurrentRelics + 1, d2CurrentRelics,     d3CurrentRelics,     d4CurrentRelics,     DivineRelicsTotal, wantedD1amount, wantedD2amount, wantedD3amount, wantedD4amount) +
      (1/3) * stateProb(remainingChests - 1, d1CurrentRelics,     d2CurrentRelics,     d3CurrentRelics + 1, d4CurrentRelics,     DivineRelicsTotal, wantedD1amount, wantedD2amount, wantedD3amount, wantedD4amount) +
      (1/3) * stateProb(remainingChests - 1, d1CurrentRelics,     d2CurrentRelics,     d3CurrentRelics,     d4CurrentRelics + 1, DivineRelicsTotal, wantedD1amount, wantedD2amount, wantedD3amount, wantedD4amount);
    cacheProbabilityStates.set(numberOfDivineRollSuccesses, val);
    return val;
  }

  // Case 6: U C U
  if (d2CurrentRelics < DivineRelicsTotal && d3CurrentRelics >= DivineRelicsTotal && d4CurrentRelics < DivineRelicsTotal) {
    val =
      (1/3) * stateProb(remainingChests - 1, d1CurrentRelics + 1, d2CurrentRelics,     d3CurrentRelics,     d4CurrentRelics,     DivineRelicsTotal, wantedD1amount, wantedD2amount, wantedD3amount, wantedD4amount) +
      (1/3) * stateProb(remainingChests - 1, d1CurrentRelics,     d2CurrentRelics + 1, d3CurrentRelics,     d4CurrentRelics,     DivineRelicsTotal, wantedD1amount, wantedD2amount, wantedD3amount, wantedD4amount) +
      (1/3) * stateProb(remainingChests - 1, d1CurrentRelics,     d2CurrentRelics,     d3CurrentRelics,     d4CurrentRelics + 1, DivineRelicsTotal, wantedD1amount, wantedD2amount, wantedD3amount, wantedD4amount);
    cacheProbabilityStates.set(numberOfDivineRollSuccesses, val);
    return val;
  }

  // Case 7: U U C
  if (d2CurrentRelics < DivineRelicsTotal && d3CurrentRelics < DivineRelicsTotal && d4CurrentRelics >= DivineRelicsTotal) {
    val =
      (1/3) * stateProb(remainingChests - 1, d1CurrentRelics + 1, d2CurrentRelics,     d3CurrentRelics,     d4CurrentRelics,     DivineRelicsTotal, wantedD1amount, wantedD2amount, wantedD3amount, wantedD4amount) +
      (1/3) * stateProb(remainingChests - 1, d1CurrentRelics,     d2CurrentRelics + 1, d3CurrentRelics,     d4CurrentRelics,     DivineRelicsTotal, wantedD1amount, wantedD2amount, wantedD3amount, wantedD4amount) +
      (1/3) * stateProb(remainingChests - 1, d1CurrentRelics,     d2CurrentRelics,     d3CurrentRelics + 1, d4CurrentRelics,     DivineRelicsTotal, wantedD1amount, wantedD2amount, wantedD3amount, wantedD4amount);
    cacheProbabilityStates.set(numberOfDivineRollSuccesses, val);
    return val;
  }

  // Case 8: U U U
  if (d2CurrentRelics < DivineRelicsTotal && d3CurrentRelics < DivineRelicsTotal && d4CurrentRelics < DivineRelicsTotal) {
    val =
      0.25 * stateProb(remainingChests - 1, d1CurrentRelics + 1, d2CurrentRelics,     d3CurrentRelics,     d4CurrentRelics,     DivineRelicsTotal, wantedD1amount, wantedD2amount, wantedD3amount, wantedD4amount) +
      0.25 * stateProb(remainingChests - 1, d1CurrentRelics,     d2CurrentRelics + 1, d3CurrentRelics,     d4CurrentRelics,     DivineRelicsTotal, wantedD1amount, wantedD2amount, wantedD3amount, wantedD4amount) +
      0.25 * stateProb(remainingChests - 1, d1CurrentRelics,     d2CurrentRelics,     d3CurrentRelics + 1, d4CurrentRelics,     DivineRelicsTotal, wantedD1amount, wantedD2amount, wantedD3amount, wantedD4amount) +
      0.25 * stateProb(remainingChests - 1, d1CurrentRelics,     d2CurrentRelics,     d3CurrentRelics,     d4CurrentRelics + 1, DivineRelicsTotal, wantedD1amount, wantedD2amount, wantedD3amount, wantedD4amount);
    cacheProbabilityStates.set(numberOfDivineRollSuccesses, val);
    return val;
  }

  // should never fall through, but just in case:
  cacheProbabilityStates.set(numberOfDivineRollSuccesses, val);
  return val;
}

function comb(numberOfAttempts, numberOfDivineRollSuccesses) {
  if (numberOfDivineRollSuccesses < 0 || numberOfDivineRollSuccesses > numberOfAttempts) return 0;
  if (numberOfDivineRollSuccesses === 0 || numberOfDivineRollSuccesses === numberOfAttempts) return 1;
  let res = 1;
  for (let i = 1; i <= numberOfDivineRollSuccesses; i++) {
    res = res * (numberOfAttempts - (numberOfDivineRollSuccesses - i)) / i;
  }
  return res;
}
function binomPMF(numberOfDivineRollSuccesses, numberOfAttempts, probabilityOfSuccess) {
  return comb(numberOfAttempts, numberOfDivineRollSuccesses) * Math.pow(probabilityOfSuccess, numberOfDivineRollSuccesses) * Math.pow(1 - probabilityOfSuccess, numberOfAttempts - numberOfDivineRollSuccesses);
}


function RELIC_SOLVER (TotalRelicChests, TotalDivineChests, TotalDivineRelics, divineChance, wantedD1amount, wantedD2amount, wantedD3amount, wantedD4amount) {
  let sectionSum = 0
  for (let numberOfDivineRollSuccesses = 0; numberOfDivineRollSuccesses <= TotalRelicChests; numberOfDivineRollSuccesses++) {
    if (Number.isNaN(binomPMF(numberOfDivineRollSuccesses, TotalRelicChests, divineChance))) {
      console.log("numberOfDivineRollSuccesses=", numberOfDivineRollSuccesses, "FINAL RESULT =", sectionSum, "avg gems after numberOfDivineRollSuccesses=", (Math.round(200/sectionSum)).toLocaleString());
      return  sectionSum;
}
    sectionSum+= binomPMF(numberOfDivineRollSuccesses, TotalRelicChests, divineChance) * RUN_STATE(numberOfDivineRollSuccesses + TotalDivineChests, 1.0, 0, 0, 0, 0, TotalDivineRelics, wantedD1amount, wantedD2amount, wantedD3amount, wantedD4amount)
    console.log("numberOfDivineRollSuccesses=", numberOfDivineRollSuccesses, "prob after numberOfDivineRollSuccesses =", sectionSum, "avg gems after numberOfDivineRollSuccesses=", (Math.round(200/sectionSum)).toLocaleString());
  }
  console.log("FINAL RESULT =", sectionSum, "avg gems after numberOfDivineRollSuccesses=", (Math.round(200/sectionSum)).toLocaleString());
  return sectionSum;
}

// TODO: Make this user selectable

let TotalRelicChests =325160
let TotalDivineChests = 6; // amount of divine chests
let TotalDivineRelics = 7; // how many divines you have in total
let divineChance = 1/25000
let wantedD1amount = 8, wantedD2amount = 7, wantedD3amount = 7, wantedD4amount = 7; // amount of divine relics across all 4 divine relic types (or the wanted amount, idk)

RELIC_SOLVER (TotalRelicChests, TotalDivineChests, TotalDivineRelics, divineChance, wantedD1amount, wantedD2amount, wantedD3amount, wantedD4amount);


    // ---------------------------

    const app = Vue.createApp({
      data() {
        return {
          TotalRelicChests: 325160,
          TotalDivineChests: 6,
          TotalDivineRelics: 7,
          divineChance: 1/25000,
          // cost per full run (gems per session of opening `TotalRelicChests` chests)
          costPerRun: 200,
          // Wanted amounts (editable via UI)
          wantedD1amount: 8,
          wantedD2amount: 7,
          wantedD3amount: 7,
          wantedD4amount: 7,
          // Label strings: edit these in the code to customize text shown next to inputs
          labelTotalRelicChests: 'TotalRelicChests:',
          labelTotalDivineChests: 'TotalDivineChests:',
          labelTotalDivineRelics: 'TotalDivineRelics:',
          labelDivineChance: 'divineChance:',
          labelCostPerRun: 'Cost per full run (gems):',
          labelWantedD1: 'wantedD1amount:',
          labelWantedD2: 'wantedD2amount:',
          labelWantedD3: 'wantedD3amount:',
          labelWantedD4: 'wantedD4amount:',
          output: "Click Run Solver"
        };
      },
      methods: {
        runSolver() {
          const prob = RELIC_SOLVER(
            this.TotalRelicChests,
            this.TotalDivineChests,
            this.TotalDivineRelics,
            this.divineChance,
            this.wantedD1amount,
            this.wantedD2amount,
            this.wantedD3amount,
            this.wantedD4amount
          );

          // Format a few helpful values
          const percent = (prob * 100).toFixed(6) + "%";
          const oneInN = (prob > 0) ? (`1 in ${Math.round(1 / prob).toLocaleString()}`) : '∞';
          const expectedRuns = (prob > 0) ? (1 / prob) : Infinity;
          const expectedGems = (prob > 0) ? Math.round(this.costPerRun * expectedRuns) : '∞';

          // Multi-line output in the <pre>
          this.output =
            `Probability (decimal): ${prob}\n` +
            `Probability (percent): ${percent}\n` +
            `One-in-N (approx): ${oneInN}\n` +
            `Expected runs (avg): ${isFinite(expectedRuns) ? expectedRuns.toFixed(2) : '∞'}\n` +
            `Expected gems (avg): ${isFinite(expectedGems) ? expectedGems.toLocaleString() : '∞'}`;
        }
      }
    });

    app.mount("#app");
  </script>
</body>
</html>
